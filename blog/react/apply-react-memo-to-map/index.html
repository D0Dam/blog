<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">React.memo와 지도 커스텀 마커 | d0dam&#x27;s-log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://d0dam.xyz/blog/react/apply-react-memo-to-map"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="React.memo와 지도 커스텀 마커 | d0dam&#x27;s-log"><meta data-rh="true" name="description" content="지도에 여러 위치를 표시하기 위해서 저희는 마커를 많이 사용합니다. 기본적으로 지도가 변할 때 마다 지도에 보이는 영역의 마커를 전부 새로 렌더링 하는 것이 기본입니다. 이 과정을 좀 더 효율적으로 만들어 보고자 합니다."><meta data-rh="true" property="og:description" content="지도에 여러 위치를 표시하기 위해서 저희는 마커를 많이 사용합니다. 기본적으로 지도가 변할 때 마다 지도에 보이는 영역의 마커를 전부 새로 렌더링 하는 것이 기본입니다. 이 과정을 좀 더 효율적으로 만들어 보고자 합니다."><meta data-rh="true" name="keywords" content="React,react 지도,react memo,memo,메모이제이션"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-11-08T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/d0dam"><meta data-rh="true" property="article:tag" content="React"><link data-rh="true" rel="icon" href="/img/logos/favicon.ico"><link data-rh="true" rel="canonical" href="https://d0dam.xyz/blog/react/apply-react-memo-to-map"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/apply-react-memo-to-map" hreflang="ko"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/apply-react-memo-to-map" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://d0dam.xyz/blog/react/apply-react-memo-to-map","mainEntityOfPage":"https://d0dam.xyz/blog/react/apply-react-memo-to-map","url":"https://d0dam.xyz/blog/react/apply-react-memo-to-map","headline":"React.memo와 지도 커스텀 마커","name":"React.memo와 지도 커스텀 마커","description":"지도에 여러 위치를 표시하기 위해서 저희는 마커를 많이 사용합니다. 기본적으로 지도가 변할 때 마다 지도에 보이는 영역의 마커를 전부 새로 렌더링 하는 것이 기본입니다. 이 과정을 좀 더 효율적으로 만들어 보고자 합니다.","datePublished":"2023-11-08T00:00:00.000Z","author":{"@type":"Person","name":"minjae Kim","url":"https://github.com/d0dam","email":"smallkdb@gmail.com","image":"https://avatars.githubusercontent.com/u/51052049?v=4"},"keywords":["React","react 지도","react memo","memo","메모이제이션"],"isPartOf":{"@type":"Blog","@id":"https://d0dam.xyz/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d0dam&#39;s-log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d0dam&#39;s-log Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-DBVZBC9QT5","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DBVZBC9QT5"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DBVZBC9QT5",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.c41d10ff.css">
<script src="/assets/js/runtime~main.bd78b476.js" defer="defer"></script>
<script src="/assets/js/main.1d2c63fc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" target="_self" href="/"><div class="navbar__logo"><img src="/img/logos/main.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logos/darkModeMain.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/overview">Documents</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/make-select">Select 컴포넌트 css 커스텀을 위한 여정</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/tanstack-query-ts-and-undefined">tanstack query + ts에서 undefined 매개변수 엄격하게 처리하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/tanstack-query-options">tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/config-stylelint">styled-components stylelint적용과 자동수정(feat. yarn berry에서 pnpm으로)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/implement-drag-scroll">마우스 드래그 스크롤 구현하기</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">React.memo와 지도 커스텀 마커</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-11-08T00:00:00.000Z">2023년 11월 8일</time> · <!-- -->약 12분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/51052049?v=4" alt="minjae Kim"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer"><span>minjae Kim</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>지도에 여러 위치를 표시하기 위해서 저희는 마커를 많이 사용합니다. 기본적으로 지도가 변할 때 마다 지도에 보이는 영역의 마커를 전부 새로 렌더링 하는 것이 기본입니다. 이 과정을 좀 더 효율적으로 만들어 보고자 합니다.</p>
<h2 id="지도-마커-만들기">지도 마커 만들기</h2>
<p><a href="https://celuveat.com/map">셀럽잇 프로젝트</a> (유명인이 다녀간 음식점 안내 서비스)를 진행하면서 겪은 일입니다. <a href="https://github.com/woowacourse-teams/2023-celuveat/pull/497">해당 PR</a></p>
<p>음식점 위치를 지도상에서 마커로 보여주는 작업을 진행했습니다.
지도는 google map api를 사용했습니다.
google map api에서는 별도의 <a href="https://developers.google.com/maps/documentation/javascript/markers?hl=ko">마커 기능을 지원</a>하지만 이 마커는 사용하지 않았습니다.</p>
<p>서비스에서 제공하려는 마커는 다음과 같은 특징을 갖습니다.</p>
<ul>
<li>호버 및 클릭시 이벤트를 제공할 수 있어야 합니다.</li>
<li>특정 조건에 따라 마커를 다르게 그려야 합니다.</li>
</ul>
<p>따라서 마커가 아이콘이나 이미지가 아닌 컴포넌트 형태여야 했습니다.</p>
<p>그래서 다음과 같은 OverlayMarker를 만들  어서 지도에 입혀주었습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;OverlayMarker.tsx&quot;">// 기존 코드를 이해를 위해 간소화하고 변형하였습니다.

interface OverlayMarkerProps {
  celeb: { id: number; name: string; profileImageUrl: string };
  map: google.maps.Map;
  restaurant: { id: number; name: string; lat: number; lng: number };
}

function OverlayMarker({ celeb, map, restaurant }: OverlayMarkerProps) {
  const { id, name, lat, lng } = restaurant;
  const [isClicked, setIsClicked] = useState(false);
  const ref = useRef();
  const hoveredId = useHoveredRestaurantState((state) =&gt; state.id);

  const clickMarker = () =&gt; setIsClicked(true);

  return (
    map &amp;&amp; (
      //Overlay 컴포넌트에 자식요소가 props로 전달한 position에 맞게 지도에 Overlay됩니다.
      &lt;Overlay position={{ lat, lng }} map={map} zIndex={isClicked || hoveredId === restaurantId ? 10 : 0}&gt;
        &lt;StyledMarkerContainer ref={ref}&gt;
          &lt;StyledMarker
            onClick={clickMarker}
            isClicked={isClicked}
            isRestaurantHovered={hoveredId === restaurantId}
            data-cy={`${restaurant.name} 마커`}
          &gt;
            &lt;ProfileImage name={celeb.name} imageUrl={celeb.profileImageUrl} size=&quot;32px&quot; /&gt;
          &lt;/StyledMarker&gt;
        &lt;/StyledMarkerContainer&gt;
      &lt;/Overlay&gt;
    )
  );
}

export default OverlayMarker;
</code></pre>
<admonition type="tip"><p>Overlay 컴포넌트를 제작할 때는 아래의 글을 참고했습니다.
만드는 과정이 궁금하다면 읽어보세요:)</p><p><a href="https://betterprogramming.pub/building-a-custom-google-maps-marker-react-component-like-airbnb-in-next-js-52fb37ccfabb">Building a Custom Google Maps Marker React Component Like Airbnb in Next.js</a></p></admonition>
<h2 id="문제-확인">문제 확인</h2>
<p>이제 한 번 지도에서 마커가 어떻게 표시 되는지 확인해볼까요?</p>
<div style="margin-bottom:20px;width:640px;height:360px"></div>
<p>보다시피 지도가 움직일 때 마다 마커 전부를 새로 그리고 있습니다.
문제는 2가지 입니다.</p>
<ol>
<li>단순 fetch를 사용해 마커에 데이터를 받고 있으며, 캐싱 로직이 아직 없습니다.</li>
</ol>
<ul>
<li>따라서 지도의 영역이 바뀔 때 마다 데이터를 fetch 해와서 새로 입히고 있습니다.</li>
</ul>
<ol start="2">
<li>지도의 영역이 바뀌면 부모 컴포넌트인 Map 자체가 리렌더링됩니다.</li>
</ol>
<ul>
<li>따라서 자식 요소인 OverlayMarker도 리렌더링이 일어납니다.</li>
</ul>
<p>fetch 로직의 경우 앞으로 tanstack-query를 도입할 가능성이 있었습니다.
tanstack-query를 도입하게 되면 자연스럽게 캐싱을 해주기 때문에 첫 번째 문제는 우선순위를 뒤로 두었습니다.</p>
<p>그래서 이번 포스트에서는 두 번째 문제를 해결해보고자 합니다.</p>
<h2 id="reactmemo-사용하기">React.memo 사용하기</h2>
<p>제가 원하는 동작은 props가 동일한 marker들은 리렌더링이 일어나지 않게 막는 것입니다.
이렇게 되면 지도에 새롭게 그려지는 마커만 새롭게 렌더링이 되고, 지도 영역에 이미 그려진 마커는 렌더링이 다시 일어나지 않고 남아있게 됩니다.</p>
<p>컴포넌트에 동일한 props가 들어올 때 렌더링을 방지하고 싶으면 <a href="https://react.dev/reference/react/memo">React.memo</a>를 사용합니다.</p>
<p>그럼 한번 react memo를 적용해 보도록 하죠.</p>
<pre><code class="language-tsx" metastring="title=&quot;OverlayMarker.tsx&quot;">interface OverlayMarkerProps {
  celeb: { id: number; name: string; profileImageUrl: string };
  map: google.maps.Map;
  restaurant: { id: number; name: string; lat: number; lng: number };
}

//highlight-next-line
function OverlayMarker({ celeb, map, restaurant }: OverlayMarkerProps) {...} // 생략

export default React.memo(OverlayMarker); // React.memo로 OverlayMarker를 감싸주었습니다.
</code></pre>
<p>이렇게 해도 지도의 마커들은 여전히 새로 그려집니다.
생각대로 동작하지 않는 이유가 두 가지정도 생각납니다.</p>
<ol>
<li>props로 전달되는 celeb과 restaurant은 객체입니다.</li>
<li>props로 전달되는 map이 내부적으로 바뀔 수도 있습니다.</li>
</ol>
<h3 id="props로-전달되는-celeb과-restaurant은-객체입니다">props로 전달되는 celeb과 restaurant은 객체입니다.</h3>
<p><strong>props로 객체가 전달</strong>된다는 점을 주목해볼까요?</p>
<p>React.memo는 props가 바뀌었다는 것을 판단할 때 <strong>얕은 비교</strong>를 진행합니다.
따라서 이전의 props와의 얕은 비교 결과가 같지 않을 때마다 컴포넌트가 리렌더링 됩니다.</p>
<p>구체적으로 이야기하자면 React는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> 비교를 사용하여 컴포넌트의 모든 prop을 이전 값과 비교합니다.</p>
<pre><code class="language-ts">Object.is(3, 3); // true
Object.is(NaN, NaN); // true
Object.is(-0, 0); // false
Object.is(&#x27;1&#x27;, 1); // false
Object.is({}, {}); // false
</code></pre>
<p>따라서 상위 컴포넌트에서 객체를 전달해 줄때 useMemo를 사용해서 기존의 객체 상태를 보전해 줄 수 있습니다.</p>
<p>예시로 celeb 객체 상태를 보전해주기 위해서는 다음과 같이 짤 수 있습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Map.tsx&quot;">// 이해를 위해서 로직을 간소화 했습니다.

function Map() {
	const [celebId, setCelebId] = useState(1);
	const [celebName, setCelebName] = useState(&#x27;도담&#x27;);
	const [profileImageUrl, setProfileImageUrl] = useState(&#x27;프로필 이미지 경로&#x27;);

  // google maps 에서 지원하는 함수입니다.
  // 지도의 보이는 영역에 변화가 생기면 호출됩니다.
	const onIdle = () =&gt; {...} // fetch를 통해 응답받은 데이터를 state에 저장하는 로직이 들어갑니다.

  // highlight-start
  const celeb = useMemo(
    () =&gt; ({ celebId, celebName, profileImageUrl }),
    [celebId, celebName, profileImageUrl]
  );
  // highlight-end

	return &lt;Map onIdle={onIdle}&gt;&lt;OverlayMarker celeb={celeb} ... /&gt;&lt;/Map&gt;
}

function OverlayMarker({ celeb, map, restaurant }: OverlayMarkerProps) {...} // 생략

export default React.memo(OverlayMarker);
</code></pre>
<h3 id="props로-전달되는-map이-내부적으로-바뀔-수도-있습니다">props로 전달되는 map이 내부적으로 바뀔 수도 있습니다.</h3>
<p>하지만 전달되는 객체가 celeb과 restaurant로 이를 다 useMemo로 관리해주기 어렵습니다.
Map에 OverlayMarker가 여러개 들어가게 되면 더욱 관리가 어려워지겠죠.</p>
<p>여기서 추가적으로 OverlayMarker에는 map 이라는 prop도 전달이 되어야 합니다.
map의 경우 google maps 객체 형태로 전달이 됩니다. 내부적으로 값이 어떻게 바뀌는지도 파악하기 어렵기 때문에 더더욱 다른 방법을 찾아봐야합니다.</p>
<p>React.memo의 두 번째 인자에 주목해 봅시다.</p>
<pre><code class="language-tsx" metastring="title=&quot;React.memo 형식&quot;">const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
</code></pre>
<p>arePropsEqual은 사용자 정의 함수라고 합니다.</p>
<p>지금과 같이 메모화된 컴포넌트의 props 변경을 최소화하는 것이 매우 힘들 때(불가능 할 때) 사용할 수 있습니다.
이 경우 React가 얕은 비교를 사용하는 대신에 이전 props와 새로운 props를 비교할 수 있도록 합니다.</p>
<p>OverlayMarker는 이전 props와 같다는 것을 celeb.id와 restaurant.id를 이용해 표현해 줄 수 있습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;OverlayMarker.tsx&quot;">interface OverlayMarkerProps {
  celeb: { id: number; name: string; profileImageUrl: string };
  map: google.maps.Map;
  restaurant: { id: number; name: string; lat: number; lng: number };
}

function OverlayMarker({ celeb, map, restaurant }: OverlayMarkerProps) {...} // 생략

//highlight-start
function areEqual(prevProps: OverlayMarkerProps, nextProps: OverlayMarkerProps) {
  const { restaurant: prevRestaurant, celeb: prevCeleb } = prevProps;
  const { restaurant: nextRestaurant, celeb: nextCeleb } = nextProps;

  // 이전 props와 현재 props가 동일한 restaurant.id, celeb.id를 갖는지 확인합니다.
  return prevRestaurant.id === nextRestaurant.id &amp;&amp; prevCeleb.id === nextCeleb.id;
}

export default React.memo(OverlayMarker, areEqual);
//highlight-end
</code></pre>
<admonition title="충분히 고려해봅시다." type="danger"><p>사용자 정의 함수를 사용하는 것은 정말 마지막 수단입니다.
오히려 사용자 정의 함수를 사용함으로써 속도가 더욱 느려질 수 있습니다.
또한 React에서는 사용자 정의 함수를 사용하게 되면 <a href="https://react.dev/reference/react/memo#specifying-a-custom-comparison-function">모든 props를 비교해야 한다</a>고 명시하고 있습니다.</p><p>위와 같이 사용하는것은 사실 굉장히 위험하죠. 정말 특별한 경우가 아니라면 지양해 주세요.</p></admonition>
<p>이제 원하는대로 동작을 잘 하는군요!</p>
<div style="margin-bottom:20px;width:640px;height:360px"></div>
<h2 id="그럼에도-불구하고">그럼에도 불구하고</h2>
<p>왜 사용자 정의 함수를 사용했냐구요?</p>
<ul>
<li>우선 이미지가 사용되었기 때문입니다.<!-- -->
<ul>
<li>많으면 한번의 지도 이동으로 18개의 이미지를 불러와야 합니다.</li>
<li>리렌더링하는 것 보다는 사용자 정의 함수를 사용한 memo가 속도면에서도, 사용자 측면에서도 이점을 얻을 수 있다고 보았습니다.</li>
</ul>
</li>
<li>데이터 구조에 대한 확신을 가지고 있었습니다.<!-- -->
<ul>
<li>OverlayMarker가 갖는 restaurant.id와 celeb.id 쌍에 대해 고유하다고 확신할 수 있습니다.</li>
</ul>
</li>
<li>추후에 tanstack-query를 도입하게되면 해당 로직 제거를 고려할 수 있습니다.<!-- -->
<ul>
<li>데이터 캐싱이 가능해지고 리렌더링 방지에 따른 큰 이점이 없어지면 해당 로직을 추후에 제거해 볼 수 있습니다.</li>
</ul>
</li>
</ul>
<p>상당히 모험적인 도전이었지만, memo를 좀 더 효율적으로 활용할 수 있는 방향을 생각해 볼 수 있었습니다.</p>
<p>여러분도 제 경험을 통해 React.memo를 좀 더 자세히 들여다보는 시간이 되었기를 기대합니다.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/react">React</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/react/implement-drag-scroll"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">마우스 드래그 스크롤 구현하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/react/react-side-effect"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">리액트 사이드 이펙트 탐구하기</div></a></nav><div></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#지도-마커-만들기">지도 마커 만들기</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#문제-확인">문제 확인</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#reactmemo-사용하기">React.memo 사용하기</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#props로-전달되는-celeb과-restaurant은-객체입니다">props로 전달되는 celeb과 restaurant은 객체입니다.</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#props로-전달되는-map이-내부적으로-바뀔-수도-있습니다">props로 전달되는 map이 내부적으로 바뀔 수도 있습니다.</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/apply-react-memo-to-map#  그럼에도-불구하고">그럼에도 불구하고</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
        Powered by <a href="https://docusaurus.io/" target="_blank" rel="noreferrer noopener">Docusaurus 2</a>, Hosted by <a href="https://github.com/" target="_blank" rel="noreferrer noopener">github pages</a>
        <br>
        Copyright © 2022 <a href="https://github.com/d0dam" target="_blank" rel="noreferrer noopener">minjaeKim</a>. All rights reserved.
        </span></div></div></div></footer></div>
</body>
</html>