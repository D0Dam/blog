<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">Select 컴포넌트 css 커스텀을 위한 여정 | d0dam&#x27;s-log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://d0dam.xyz/blog/react/make-select"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Select 컴포넌트 css 커스텀을 위한 여정 | d0dam&#x27;s-log"><meta data-rh="true" name="description" content="native select는 자체적으로 강력한 태그라고 생각합니다. 그래서 그만큼 컴포넌트를 만들며 가장 어려움을 겪었습니다. 이 여정을 풀어볼까합니다."><meta data-rh="true" property="og:description" content="native select는 자체적으로 강력한 태그라고 생각합니다. 그래서 그만큼 컴포넌트를 만들며 가장 어려움을 겪었습니다. 이 여정을 풀어볼까합니다."><meta data-rh="true" name="keywords" content="React,select,components,select css"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-05-09T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/d0dam"><meta data-rh="true" property="article:tag" content="React,select"><link data-rh="true" rel="icon" href="/img/logos/favicon.ico"><link data-rh="true" rel="canonical" href="https://d0dam.xyz/blog/react/make-select"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/make-select" hreflang="ko"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/make-select" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://d0dam.xyz/blog/react/make-select","mainEntityOfPage":"https://d0dam.xyz/blog/react/make-select","url":"https://d0dam.xyz/blog/react/make-select","headline":"Select 컴포넌트 css 커스텀을 위한 여정","name":"Select 컴포넌트 css 커스텀을 위한 여정","description":"native select는 자체적으로 강력한 태그라고 생각합니다. 그래서 그만큼 컴포넌트를 만들며 가장 어려움을 겪었습니다. 이 여정을 풀어볼까합니다.","datePublished":"2024-05-09T00:00:00.000Z","author":{"@type":"Person","name":"minjae Kim","url":"https://github.com/d0dam","email":"smallkdb@gmail.com","image":"https://avatars.githubusercontent.com/u/51052049?v=4"},"keywords":["React","select","components","select css"],"isPartOf":{"@type":"Blog","@id":"https://d0dam.xyz/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d0dam&#39;s-log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d0dam&#39;s-log Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-DBVZBC9QT5","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DBVZBC9QT5"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DBVZBC9QT5",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.c41d10ff.css">
<script src="/assets/js/runtime~main.bd78b476.js" defer="defer"></script>
<script src="/assets/js/main.1d2c63fc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" target="_self" href="/"><div class="navbar__logo"><img src="/img/logos/main.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logos/darkModeMain.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/overview">Documents</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/react/make-select">Select 컴포넌트 css 커스텀을 위한 여정</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/tanstack-query-ts-and-undefined">tanstack query + ts에서 undefined 매개변수 엄격하게 처리하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/tanstack-query-options">tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/config-stylelint">styled-components stylelint적용과 자동수정(feat. yarn berry에서 pnpm으로)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/implement-drag-scroll">마우스 드래그 스크롤 구현하기</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Select 컴포넌트 css 커스텀을   위한 여정</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-05-09T00:00:00.000Z">2024년 5월 9일</time> · <!-- -->약 24분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/51052049?v=4" alt="minjae Kim"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer"><span>minjae Kim</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>native select는 자체적으로 강력한 태그라고 생각합니다. 그래서 그만큼 컴포넌트를 만들며 가장 어려움을 겪었습니다. 이 여정을 풀어볼까합니다.</p>
<h2 id="들어가기에-앞서">들어가기에 앞서</h2>
<ul>
<li>compound pattern을 알고, 사용할 수 있다는 전제가 깔려있습니다.</li>
<li>매끄러운 내용 진행을 위해 선택 전용 single select를 기본으로 글을 작성하였습니다.</li>
<li>매끄러운 내용 진행을 위해 코드에 생략이 있습니다.</li>
<li><code>&lt;select&gt;</code> 의 경우 native select element를 의미합니다.</li>
</ul>
<h2 id="배경">배경</h2>
<p>디자인 시스템을 구축해야 할 일이 있어 여러 기본 컴포넌트들을 만들고 있었습니다.
이 때 가장 구현이 어려웠다고 느낀 컴포넌트가 바로 Select 였습니다.
생각보다 native한 <code>&lt;select&gt;</code>의 기능을 따르면서 css 까지 원하는대로 변경하는 것은 쉽지 않았습니다.</p>
<p>왜냐하면 다른 태그들과는 다르게 <code>&lt;select&gt;</code>는 css를 한정적으로만 바꿀 수 있고,
<code>&lt;select&gt;</code>와 같이쓰이는 <code>&lt;optgroup&gt;</code>, <code>&lt;option&gt;</code> 태그도 존재하기 때문입니  다.</p>
<p>그렇다면 원하는 디자인으로 <code>&lt;select&gt;</code>를 사용하기 위해서는 어떻게 해야할지 확인해봅시다.</p>
<h2 id="다른-태그로-접근하기">다른 태그로 접근하기</h2>
<p>위에서 언급했다시피 native select element는 css를 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#styling_with_css">한정적으로만 적용</a>할 수 있습니다.
그래서 원하는 디자인대로 커스텀을 위해서는 native select 대신 이와 비슷한 기능과 구조를 가질 수 있는 태그로 대체해야 합니다.</p>
<p>기본적인 select에서 원하는 동작을 나열해 봅시다.</p>
<ul>
<li>선택한 특정 option을 보여주는 상자가 있다.</li>
<li>이 상자를 클릭하면 옵션들을 담은 상자가 나온다.</li>
<li>특정 옵션을 클릭하면 옵션들을 담은 상자가 닫힌다.</li>
<li>이외에 Esc나 외부 클릭 등으로 옵션들을 담은 상자가 닫힌다.</li>
</ul>
<p>이 기본 동작을 컴포넌트로 표현한다면 다음과 같이 표현할 수 있을 것 같습니다.</p>
<pre><code class="language-tsx">function Select({ name, children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }: SelectProps) {
  const { value: isOpen, setFalse: close, toggle } = useBooleanState(false);
  const [currentValue, setCurrentValue] = useState(defaultValue);

  const handleOptionClick = (e) =&gt; {
    close();
    setCurrentValue(e.target.value);
  };

  ...

  return (
    &lt;div&gt;
      &lt;button onClick={toggle}&gt;{선택된 옵션 이름 || placeholder}&lt;/button&gt;
      // css로 isOpen이 false 인경우 안보이게 처리
      &lt;ul $isOpen={isOpen} onKeyDown={...}&gt;
        &lt;li onClick={handleOptionClick} value=&quot;1&quot;&gt;
          option 1
        &lt;/li&gt;
        &lt;li onClick={handleOptionClick} value=&quot;2&quot;&gt;
          option 2
        &lt;/li&gt;
        &lt;li onClick={handleOptionClick} value=&quot;3&quot;&gt;
          option 3
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>이 구조를 베이스로 native에 근접한 Select를 구현해봅시다.</p>
<h2 id="native-select와-구조-맞추기">native select와 구조 맞추기</h2>
<p>select를 구현하는 방식은 크게 두 가지로 확인할 수 있었습니다.</p>
<ul>
<li>
<p>props로 <code>{ value, name }</code> 꼴의 <code>&lt;option&gt;</code>에 담기는 정보 배열을 전달하기.</p>
<ul>
<li>
<pre><code class="language-tsx">function SelectExample() {
  return (
    &lt;Select
      options={[
        { value: 1, name: &#x27;option 1&#x27; },
        { value: 2, name: &#x27;option 2&#x27; },
        { value: 3, name: &#x27;option 3&#x27; },
      ]}
    /&gt;
  );
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>compound pattern</code> 등을 사용해 컴포넌트 자식으로 option을 사용할 수 있도록 하기.</p>
<ul>
<li>
<pre><code class="language-tsx">function SelectExample() {
  return (
    &lt;Select&gt;
      &lt;Select.Option value=&quot;1&quot;&gt;option 1&lt;/Select.Option&gt;
      &lt;Select.Option value=&quot;2&quot;&gt;option 2&lt;/Select.Option&gt;
      &lt;Select.Option value=&quot;3&quot;&gt;option 3&lt;/Select.Option&gt;
    &lt;/Select&gt;
  );
}
</code></pre>
</li>
</ul>
</li>
</ul>
<p>첫 번째 방법으로 구현을 하게 되면 구현 난이도 및 코드량 자체는 낮아집니다.
하지만 <code>&lt;option&gt;</code>에서 다루는 값을 props으로 다룬다는 점과
native select의 형태와는 사용할 때 거리가 멀다는 점이 마음에 들지 않았습니다.</p>
<p>두 번째 방법은 어떨까요?
첫 번째 방법에 비해 구현 난이도와 코드량 자체는 높아질테지만
첫 번째 방법으로 구현했을 때 나타나는 단점들을 무마할 수 있습니다.</p>
<h3 id="select-안에-들어갈-요소-정하기">Select 안에 들어갈 요소 정하기</h3>
<p>Select 구현 방식을 정했으니 Select 자식에 쓰일 컴포넌트로 무엇이 올 수 있을지 정의해 봅시다.</p>
<p><code>&lt;select&gt;</code>   내부에 사용하는 전용 태그는 <code>&lt;option&gt;</code>, <code>&lt;optgroup&gt;</code>두 가지입니다.
그리고 특정 <code>&lt;option&gt;</code>, <code>&lt;optgroup&gt;</code> 사이를 구분하기 위해 <code>&lt;hr&gt;</code>를 사용하기도 합니다.</p>
<p>이 세 가지 태그를 내부에서 정의해 사용할 수 있도록 하면 될 것 같네요!
저는 작업하는 디자인 시스템에 맞게 <code>Slot</code>, <code>SlotGroup</code>, <code>Divider</code> 라는 이름으로 만들어주었습니다.</p>
<pre><code>└── 📁Select
    └── 📁Slot
    └── 📁SlotGroup
    └── 📁Divider
</code></pre>
<p>Compound pattern을 사용해 <code>Select</code>에서 <code>Slot</code>, <code>SlotGroup</code>, <code>Divider</code>를 사용할 수 있도록합니다.
<code>Divider</code>는 로직과 관련 없는 디자인적 요소이므로 생략하겠습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Select.tsx&quot;">... // compound pattern을 위한 context 세팅

function Select({ children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }) {
  const { value: isOpen, setFalse: close, toggle } = useBooleanState(false);
  const [currentValue, setCurrentValue] = useState(defaultValue);

  const contextValue = useMemo(
    () =&gt; ({ close, currentValue, setCurrentValue }),
    [close, currentValue, setCurrentValue],
  );

  return (
    &lt;SelectContext.Provider value={contextValue}&gt;
      &lt;S.SelectContainer&gt;
        &lt;S.SelectButton onClick={toggle}&gt;{선택된 옵션 이름 || placeholder}&lt;/S.SelectButton&gt;

        &lt;S.OptionList $isOpen={isOpen}&gt;{children}&lt;/S.OptionList&gt;
      &lt;/S.SelectContainer&gt;
    &lt;/SelectContext.Provider&gt;
  );
}
</code></pre>
<pre><code class="language-tsx" metastring="title=&quot;Slot.tsx&quot;">function Slot({ value, children, disabled = false }) {
  const { currentValue, setCurrentValue, close } = useSelectContext();

  const handleClick = () =&gt; {
    if (disabled) return;

    setCurrentValue(value);
    close();
  };

  return (
    &lt;S.Li
      value={value}
      onClick={handleClick}
      $disabled={disabled}
      $selected={currentValue === value}
    &gt;
      {children}
    &lt;/S.Li&gt;
  );
}
</code></pre>
<pre><code class="language-tsx" metastring="title=&quot;SlotGroup.tsx&quot;">function SlotGroup({ children, label }) {
  return (
    &lt;S.Container&gt;
      &lt;S.Label htmlFor={label}&gt;{label}&lt;/S.Label&gt;
      &lt;ul id={label}&gt;{children}&lt;/ul&gt;
    &lt;/S.Container&gt;
  );
}
</code></pre>
<p>아래와 같은 구조로 이제 사용할 수 있도록 준비를 마쳤습니다!</p>
<pre><code class="language-tsx">function SelectExample() {
  return (
    &lt;Select name=&quot;example&quot; placeholder=&quot;text&quot;&gt;
      &lt;Select.Slot value=&quot;1&quot;&gt;Option 1&lt;/Select.Slot&gt;
      &lt;Select.Slot value=&quot;11&quot;&gt;Option 11&lt;/Select.Slot&gt;
      &lt;Select.SlotGroup label=&quot;group&quot;&gt;
        &lt;Select.Slot value=&quot;www&quot;&gt;Option www&lt;/Select.Slot&gt;
        &lt;Select.Slot value=&quot;xxx&quot;&gt;Option xxx&lt;/Select.Slot&gt;
        &lt;Select.Slot value=&quot;zzz&quot;&gt;Option zzz&lt;/Select.Slot&gt;
      &lt;/Select.SlotGroup&gt;
      &lt;Select.Divider /&gt;
      &lt;Select.Slot value=&quot;2&quot;&gt;Option 2&lt;/Select.Slot&gt;
      &lt;Select.Slot value=&quot;22&quot;&gt;Option 22&lt;/Select.Slot&gt;
    &lt;/Select&gt;
  );
}
</code></pre>
<h2 id="focus-구현">Focus 구현</h2>
<p><code>&lt;select&gt;</code>에서 focus는 다분하게 바뀔 수 있습니다.
<code>&lt;select&gt;</code>가 아닌 자체 커스텀 Select를 사용한다면 <code>&lt;select&gt;</code>에서 일어나는 focus 처리를 해 주어야 합니다.</p>
<p>또한 Focus를 구현하기 위해 사용하는 방법으로 다른 <code>&lt;select&gt;</code>의 동작도 충분히 구현할 수 있습니다.
기본적으로 <code>&lt;select&gt;</code>에서 focus가 일어나는 상황을 정리해보겠습니다.</p>
<ol>
<li><code>&lt;select&gt;</code> 상자 클릭 시 현재 select된 옵션이 focus</li>
<li>각각의 <code>&lt;option&gt;</code>에 마우스 hover 시 해당 옵션이 focus</li>
<li>화살표 위, 아래 키를 누르면 현재 focus된 옵션의 위, 아래 옵션이 focus</li>
<li><code>&lt;option&gt;</code> 클릭 시 옵션 상자를 벗어나서 <code>&lt;select&gt;</code> 상자에 focus</li>
<li>space, 엔터, Esc 키를 누르거나 옵션 상자 이외의 영역을 클릭해 옵션 상자를 벗어나면 <code>&lt;select&gt;</code> 상자에 focus</li>
</ol>
<p>등 <a href="https://www.w3.org/WAI/ARIA/apg/patterns/combobox/">추가적으로 더 존재</a>하지만 위의 항목들을 중점으로 다뤄보겠습니다.</p>
<hr>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#try_it">직접 확인해보기</a></p>
<hr>
<p>react에서는 focus를 위해 특정 요소의 ref를 참조해야합니다.
ref를 사용해 위의 focus 상황을 하나씩 해결해 봅시다.</p>
<h3 id="slot">Slot</h3>
<p>Slot 컴포넌트에서는 2번, 4번 상황을 해결할 수 있습니다.</p>
<ul>
<li>2번 - 각각의 <code>&lt;option&gt;</code>에 마우스 hover 시 해당 옵션이 focus</li>
<li>4번 - <code>&lt;option&gt;</code> 클릭 시 옵션 상자를 벗어나서 <code>&lt;select&gt;</code> 상자에 focus</li>
</ul>
<p>2번의 경우 단순하게 <code>onMouseEnter</code>시 disabled가 아니라면 focus를 주고 <code>onMouseLeave</code> 시 blur를 줍니다.</p>
<p>4번의 경우 옵션 클릭 시 Select 컴포넌트 button의 ref를 가져와 focus를 줍니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Slot.tsx&quot;">function Slot({ value, children, disabled = false }) {
  const slotRef = useRef&lt;HTMLLIElement | null&gt;(null);
  const { currentValue, setCurrentValue, close, selectButtonRef } = useSelectContext();

  const handleClick = () =&gt; {
    if (disabled) return;

    setCurrentValue(value);
    close();
    // highlight-next-line
    selectButtonRef.current?.focus();
  };

  // highlight-start
  const handleMouseEnter = () =&gt; {
    if (disabled) return;

    slotRef.current?.focus();
  };

  const handleMouseLeave = () =&gt; {
    if (disabled) return;

    slotRef.current?.blur();
  };
  // highlight-end

  return (
    &lt;S.Li
      // highlight-next-line
      ref={slotRef}
      value={value}
      onClick={handleClick}
      // highlight-next-line
      onMouseEnter={handleMouseEnter}
      // highlight-next-line
      onMouseLeave={handleMouseLeave}
      $disabled={disabled}
      $selected={currentValue === value}
    &gt;
      {children}
    &lt;/S.Li&gt;
  );
}
</code></pre>
<h3 id="select">Select</h3>
<p>Select 컴포넌트에서는 5번 상황을 해결할 수 있습니다.</p>
<ul>
<li>5번 - space, 엔터, Esc 키를 누르거나 옵션 상자 이외의 영역을 클릭해 옵션 상자를 벗어나면 <code>&lt;select&gt;</code> 상자에 focus</li>
</ul>
<p>공통적으로 <code>&lt;button&gt;</code>에 focus를 주고 옵션 상자를 닫는 일을 하고 있습니다.
이 일을 하기 위한 이벤트가 optionList의 keydown, 옵션 상자 외부 클릭이며 이 이벤트가 발생할 때 focus를 줄 수 있도록 합니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Select.tsx&quot;">... // compound pattern을 위한 context 세팅

function Select({ children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }) {
  const selectRef = useRef&lt;HTMLDivElement | null&gt;(null);
  const selectButtonRef = useRef&lt;HTMLButtonElement | null&gt;(null);

  ...

  const closeOptionList = () =&gt; {
    close();
    selectButtonRef.current?.focus();
  }

  const handleOptionListKeyDown: React.KeyboardEventHandler&lt;HTMLUListElement&gt; = (e) =&gt; {
    // 이미 이벤트가 실행되는 중이라면 아무 동작도 하지 않습니다.
    if (e.defaultPrevented) return;

    switch (e.key) {
      ...
      case &#x27; &#x27;:
      case &#x27;Enter&#x27;:
        closeOptionList();
        break;
      case &#x27;Esc&#x27;:
      case &#x27;Escape&#x27;:
        closeOptionList();
        break;
      default:
        return;
    }

    e.preventDefault();
  }

  useOnClickOutside(selectRef, closeOptionList);

  return (
    &lt;SelectContext.Provider value={contextValue}&gt;
      &lt;S.SelectContainer ref={selectRef}&gt;
        &lt;S.SelectButton ref={selectButtonRef} onClick={toggle}&gt;{currentValue || placeholder}&lt;/S.SelectButton&gt;

        &lt;S.OptionList $isOpen={isOpen} onKeyDown={handleOptionListKeyDown}&gt;{children}&lt;/S.OptionList&gt;
      &lt;/S.SelectContainer&gt;
    &lt;/SelectContext.Provider&gt;
  );
}
</code></pre>
<h3 id="option-ref-모으기">option ref 모으기</h3>
<p>조금 어려운 부분은 1, 3번 상황입니다.</p>
<ul>
<li>1번 - <code>&lt;select&gt;</code> 상자 클릭 시 현재 select된 옵션이 focus</li>
<li>3번 - 화살표 위, 아래 키를 누르면 현재 focus된 옵션의 위, 아래 옵션이 focus</li>
</ul>
<p>이 두 가지 상황의 경우 특정 요소를 눌렀는데 다른 요소가 focus되어야 하거나 나열된 같은 컴포넌트로 이루어진 요소의 ref를 모두 가지고 있어야 하기 때문입니다.</p>
<p>공통적으로 두 가지 상황 모두 옵션들의 ref가 있어야 focus를 할 수 있다는 점입니다.
그렇다면 모든 옵션들의 ref를 가져와봅시다.</p>
<p>모든 옵션들의 ref를 가져오기 위해 Select에서 compound pattern을 위해 사용하는 context를 활용합니다.
Select에 모든 옵션들의 ref를 저장할 ref를 만들고, 이 ref를 Slot에서 가져가 사용할 수 있도록 할것입니다.
여기에서 생각해 보아야 할 점은 <strong><code>모든 옵션들이 가지는 각기 다른 고유의 값은 무엇일까?</code></strong> 입니다.
바로 생각나는 것은 옵션의 <code>value</code> 혹은 <code>index</code>, <code>ref</code> 그 자체가 될 수 있겠네요.</p>
<p>옵션의 <code>value</code>의 경우 중복되는 경우가 존재하지 않는 다는 전제가 있습니다.
중복된다고 하면 1번 상황에 대해 특정 option을 가려내기 어려울 수 있습니다.
하지만 중복이 불가능하지는 않다는 점이 살짝 걸렸습니다.</p>
<p><code>index</code> 의 경우는 select의 옵션이 동적으로 추가되는 경우에 문제가 됩니다.
물론 이러한 경우가 거의 없을지라도 불가능하지는 않죠.</p>
<p>ref 자체는 고유의 값은 맞지만 이걸 활용하는 것은 살짝 낯설었습니다.
value 와 고민을 많이 했지만 ref를 고유의 값으로 활용하기로 확정지었습니다.
ref 값은 우리가 직접 설  정해 주는것이 아닌 react 자체에서 내보내는 값이기 때문에 휴먼 에러 측면에서도 괜찮아 보였습니다.
이제 ref를 고유 키로 갖는 객체를 ref로 선언하면 되겠네요! 객체는 Map 을 사용해 보겠습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Select.tsx&quot;">interface SlotMapValue {
  ref: React.RefObject&lt;HTMLLIElement&gt;;
  value: string;
  option: string;
}

type SlotMap = Map&lt;React.RefObject&lt;HTMLLIElement&gt;, SlotMapValue&gt;;

function Select({ children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }) {
  const slotMapRef = useRef&lt;SlotMap&gt;(new Map());

  ...

  // slotMapRef를 context에 추가
  const contextValue = useMemo(
    () =&gt; ({ close, currentValue, setCurrentValue, slotMapRef, selectButtonRef }),
    [close, currentValue, setCurrentValue, slotMapRef, selectButtonRef]
  );

  ...
}
</code></pre>
<p>이제 Slot에서 slotMapRef에게 ref를 전달해줍시다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Slot.tsx&quot;">function Slot({ value, children, disabled = false }) {
  const slotRef = useRef&lt;HTMLLIElement | null&gt;(null);
  const { ..., slotMapRef } = useSelectContext();

  ...

  useEffect(() =&gt; {
    const slotElementMap = slotMapRef.current;

    if (slotElementMap instanceof Map &amp;&amp; disabled === false) {
        slotElementMap.set(slotRef, { ref: slotRef, value, option: children });
    }
  }, [disabled]);

 ...
}
</code></pre>
<p>이제 Select에서 slotMapRef를 활용해서 focus를 컨트롤 할 수 있습니다.</p>
<p>1번 상황의 경우 현재 select 된 옵션을 알기 위해 slotRefArray 에서 특정 value를 갖는 slotRef를 찾아내면 됩니다.
다만, 옵션 상자가 열린 후 포커스를 주어야 하기 때문에 useEffect를 사용하겠습니다.</p>
<p>slotMapRef를 통해 slotRef 배열을 만들 수 있습니다. 이 배열을 활용해보겠습니다.</p>
<pre><code class="language-ts">const slotRefArray = Array.from(slotMapRef.current.values());
</code></pre>
<pre><code class="language-tsx">useEffect(() =&gt; {
  if (isOpen) {
    const slotRefArray = Array.from(slotMapRef.current.values());
    const selectedSlot = slotRefArray.find(({ value }) =&gt; value === currentValue);

    if (selectedSlot) {
      selectedSlot.ref.current?.focus();
    } else {
      // select 된 옵션이 없는 경우 첫번째 옵션을 포커스
      slotRefArray[0].ref.current?.focus();
    }
  }
}, [isOpen]);
</code></pre>
<p>3번 상황의 경우 document에 포커스되어있는 요소를 찾고 해당 요소가 몇번째 slotRef 에 해당하는지 찾습니다.
이후에는 slotRef 배열에서 index를 조절하는 식으로 포커스를 변경할 수 있습니다.</p>
<pre><code class="language-tsx">const moveFocus = (count = 1) =&gt; {
  const slotRefArray = Array.from(slotMapRef.current.values());
  const currentIndex = slotRefArray.findIndex(({ ref }) =&gt; ref.current === document.activeElement);

  slotRefArray[currentIndex + count]?.ref.current?.focus();
};
</code></pre>
<h2 id="접근성-챙기기">접근성 챙기기</h2>
<p><code>&lt;select&gt;</code>가 아닌 다른 요소를 이용해서 &quot;select 처럼&quot; 동작하게 했기 때문에 기본적인 스크린 리더 정보를 챙겨줄 필요가 있습니다.</p>
<p>role을 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/select_role">select role</a>을 사용할 수 있다면 좋겠지만 abstract role로 직접 명시하는 방식으로 사용하는 것을 권장하지 않습니다.(<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/select_role#best_practices">best practices</a>에도 do not use 라고 적혀있죠.)
따라서 role을 따로 주지 않거나, 이와 유사한 <code>combobox</code>를 줍시다.</p>
<h3 id="selecttsx">Select.tsx</h3>
<p>Select에서 button은 옵션 상자를 트리거 하는 역할을 합니다. 그리고 ul은 옵션 리스트를 보여줍니다.
따라서 이 두 요소간의  관계를 작성할 필요가 있습니다.</p>
<p>추가적으로 tabIndex를 활용해 focus 여부를 기재합니다.
다음과 같은 속성을 사용합니다.<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes">참고</a></p>
<ul>
<li>tabIndex</li>
<li>role</li>
<li>aria-controls</li>
<li>aria-haspopup</li>
<li>aria-expanded</li>
<li>aria-labelledby</li>
</ul>
<pre><code class="language-tsx" metastring="title=&quot;Select.tsx&quot;">function Select({ children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }) {

  ...

  return (
    &lt;SelectContext.Provider value={contextValue}&gt;
      &lt;S.SelectContainer ref={selectRef}&gt;
        &lt;S.SelectButton
          id=&quot;select-button&quot;
          ref={selectButtonRef}
          // highlight-start
          role=&quot;combobox&quot;
          tabIndex={0}
          aria-controls=&quot;select&quot;
          aria-haspopup=&quot;true&quot;
          aria-expanded={isOpen}
          // highlight-end
          onClick={toggle}
          $isOpen={isOpen}
        &gt;

        // highlight-next-line
        &lt;S.OptionList role=&quot;listbox&quot; aria-labelledby=&quot;select-button&quot; $isOpen={isOpen}&gt;{children}&lt;/S.OptionList&gt;
      &lt;/S.SelectContainer&gt;
    &lt;/SelectContext.Provider&gt;
  );
}
</code></pre>
<h3 id="slottsx">Slot.tsx</h3>
<p>Slot에서는 option에 해당하는 접근성을 챙겨줍니다. selected, disabled 상태 표현을 위한 ARIA와 role, tabIndex를 추가합니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Slot.tsx&quot;">function Slot({ value, children, disabled = false }) {

  ...

  return (
    &lt;S.Li
      ref={slotRef}
      value={value}
      // highlight-start
      role=&quot;option&quot;
      tabIndex={-1}
      aria-selected={currentValue === value}
      aria-disabled={disabled}
      //highlight-end
      onClick={handleClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      $disabled={disabled}
      $selected={currentValue === value}
    &gt;
      {children}
    &lt;/S.Li&gt;
  );
}
</code></pre>
<h3 id="slotgrouptsx">SlotGroup.tsx</h3>
<p>SlotGroup에서는 <code>&lt;optgroup&gt;</code>에 해당하는 접근성을 챙기기 위해 해당 <code>&lt;ul&gt;</code>에 <code>role=&quot;group&quot;</code>을 추가합니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;SlotGroup.tsx&quot;">function SlotGroup({ children, label }) {
  return (
    &lt;S.Container&gt;
      &lt;S.Label htmlFor={label}&gt;{label}&lt;/S.Label&gt;
      // highlight-next-line
      &lt;ul id={label} role=&quot;group&quot;&gt;
        {children}
      &lt;/ul&gt;
    &lt;/S.Container&gt;
  );
}
</code></pre>
<h2 id="native-select-element-활용하기">native select element 활용하기</h2>
<p>원하는 접근성과 포커스 동작도 챙겨주었지만 아직 챙기지 못한것이 있습니다.</p>
<p><code>&lt;input&gt;</code>/<code>&lt;select&gt;</code>/<code>&lt;textarea&gt;</code>는 <code>&lt;form&gt;</code>과 많이 사용하는데, 이 때 문제가 발생합니다.</p>
<h3 id="form-접근"><code>&lt;form&gt;</code> 접근.</h3>
<p><code>&lt;select&gt;</code>의 경우 <code>&lt;form&gt;</code>을 통해 name attribute에 접근해 해당하는 value를 가져올 수 있습니다.
커스텀한 Select 컴포  넌트의 경우 이 동작을 구현할 수 없죠.</p>
<pre><code class="language-tsx">// 이와같이 사용할 수 없습니다.

&lt;form
  onSubmit={(e) =&gt; {
    e.preventDefault();
    console.log(e.currentTarget.example.value);
  }}
&gt;
  &lt;select name=&quot;example&quot;&gt;
    &lt;option value=&quot;www&quot;&gt;Option www&lt;/option&gt;
    &lt;option value=&quot;xxx&quot;&gt;Option xxx&lt;/option&gt;
    &lt;option value=&quot;zzz&quot;&gt;Option zzz&lt;/option&gt;
  &lt;/select&gt;
  &lt;button type=&quot;submit&quot;&gt;콘솔로 현재 선택된 값 확인&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<h3 id="autocomplete-특성">autocomplete 특성</h3>
<p><code>&lt;select&gt;</code>의 경우 HTML <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Attributes/autocomplete">autocomplete 특성</a>을 가지고 있습니다.
하지만 커스텀한 Select는 autocomplete 특성을 가질 수 없습니다.</p>
<h3 id="따라서">따라서</h3>
<p>위의 두 가지 문제를 해결하기 위해 <code>&lt;select&gt;</code>의 경우도 커스텀 Select를 이용할 때 가지고 있는 것이 좋습니다.
대신 <code>&lt;select&gt;</code>를 숨길 필요가 있습니다.
<code>&lt;select&gt;</code> 를 숨기기 위해 <a href="https://www.a11yproject.com/posts/how-to-hide-content/">이 글에서</a> 사용한 css를 적용했습니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Select.tsx&quot;">function Select({ children, defaultValue = &#x27;&#x27;, placeholder = &#x27;&#x27; }) {

  ...

  return (
    &lt;SelectContext.Provider value={contextValue}&gt;
      &lt;S.SelectContainer ref={selectRef}&gt;
        ...
      &lt;/S.SelectContainer&gt;

      // highlight-start
      &lt;S.HiddenSelect&gt;
        &lt;select
          name={name}
          tabIndex={-1}
          value={currentValue}
          onChange={(e) =&gt; setCurrentValue(e.target.value)}
        &gt;
          ...
        &lt;/select&gt;
      &lt;/S.HiddenSelect&gt;
      // highlight-end
    &lt;/SelectContext.Provider&gt;
  );
}
</code></pre>
<h3 id="optgroup-고려하기">optgroup 고려하기</h3>
<p>이제 select안에 option들을 채워 넣으면 됩니다.
이 때 SlotGroup을 사용한 경우를 고려해야합니다. 이 경우 <code>&lt;option&gt;</code>을 <code>&lt;optgroup&gt;</code>으로 묶어주어야 하기 때문이죠.</p>
<admonition title="Q&amp;A" type="info"><p>Q: SlotGroup 안에 SlotGroup이 중첩될 수 있나요?</p><p>A: 아니요. <code>&lt;select&gt;</code>도 <code>&lt;optgroup&gt;</code>이 중첩 불가하기 때문에 이를 최대한 따라가기 위해 중첩은 허용하지 않았습니다.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup#technical_summary">permitted content</a>를 확인해보면 <code>&lt;optgroup&gt;</code>은 <code>&lt;option&gt;</code>만을 허용합니다.</p></admonition>
<p>특정 Slot이 SlotGroup안의 요소인지 판별하기 위해서는 어떻게 해야 할까요?
SlotGroup 안에 들어가는 children의 경우 추가적인 props을 전달하는 방법을 생각해 보았습니다.</p>
<p><code>React.children.map</code>과 <code>React.cloneElement</code>를 활용해서 children을 순회하며 groupLabel을 prop에 추가합니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;SlotGroup.tsx&quot;">function SlotGroup({ children, label }) {
  return (
    &lt;S.Container role=&quot;group&quot;&gt;
      &lt;S.Label htmlFor={label}&gt;{label}&lt;/S.Label&gt;
      &lt;ul tabIndex={-1} id={label} role=&quot;listbox&quot;&gt;
        // highlight-next-line
        {React.Children.map(children, (child) =&gt; React.cloneElement(child, { groupLabel: label }))}
      &lt;/ul&gt;
    &lt;/S.Container&gt;
  );
}
</code></pre>
<p>이제 Select의 slotMapRef에 저장되는 ref의 값에는 groupLabel이 optional 하게 존재합니다.</p>
<pre><code class="language-ts">interface SlotMapValue {
  ref: React.RefObject&lt;HTMLLIElement&gt;;
  value: string;
  option: string;
  groupLabel?: string;
}
</code></pre>
<p><code>&lt;select&gt;</code>의 내부 요소를 구성하기 위한 단계를 나열해 봅시다.</p>
<ul>
<li>slotMapRef.current의 값을 모아 SlotMapValue 타입의 배열로 바꾸어 줍니다.</li>
<li>groupLabel이 있는 경우 같은 groupLabel을 가진 Slot끼리 한 객체로 묶어줍니다.<!-- -->
<pre><code class="language-tsx">    const example = { groupLabel: 그룹라벨이름, options: [ option1 , option2 , ...] };
</code></pre>
</li>
<li>위 과정을 통해 얻은 객체 배열을 바탕으로 객체 안에 group이 true인 경우 options들을 <code>&lt;optgroup&gt;</code>의 자식으로 넣습니다.</li>
</ul>
<p>대략적으로 표현하자면 아래와 같습니다.</p>
<pre><code class="language-tsx">&lt;select
  name={name}
  tabIndex={-1}
  value={currentValue}
  onChange={(e) =&gt; setCurrentValue(e.target.value)}
&gt;
  {groupSlotByLabel(Array.from(slotMapRef.current.values())).map((item) =&gt; {
    if (그룹인 객체면) {
      return (
        &lt;optgroup label={item.label} key={item.label}&gt;
          {item.element.map(({ value, option }) =&gt; (
            &lt;option value={value} key={value}&gt;
              {option}
            &lt;/option&gt;
          ))}
        &lt;/optgroup&gt;
      );
    }

    return (
      &lt;option value={item.value} key={item.value}&gt;
        {item.option}
      &lt;/option&gt;
    );
  })}
&lt;/select&gt;
</code></pre>
<p>이제 <code>&lt;select&gt;</code>에 맞게 <code>&lt;form&gt;</code>을 사용하고 autocomplete 특성도 활용할 수 있게 되었습니다!</p>
<h2 id="마치며">마치며</h2>
<p>select는 결코 디자인 하기 간단한 컴포넌트가 아니라는 것을 크게 깨닫게 되었습니다.
기존 컴포넌트에서 벗어나 이 것을 그대로 흉내낸다는 것은 100% 완벽할수도 없을 뿐더러 매우 수고스러움이 들죠.
하지만 그만큼 ui에 있어 디자인이 추구하는 가치가 크다는 것을 느낄 수 있었습니다.</p>
<p>글에서는 큰 부분들만을 다루어 중간중간 생략된 부분이 많습니다.</p>
<p>추가적인 <a href="https://www.w3.org/WAI/ARIA/apg/patterns/combobox/">keyboard interaction</a>도 존재하고
Multi Select나 편집 가능한 Select, 옵션 키보드 탐색 기능 등이 있죠.</p>
<p>이 기능들까지 자세히 들여다보고 싶다면 reference를 참고해 주세요.</p>
<h2 id="reference">reference</h2>
<h3 id="접근성-태그">접근성, 태그</h3>
<ul>
<li><a href="https://mulder21c.github.io/aria-practices/examples/combobox/combobox-select-only.html">https://mulder21c.github.io/aria-practices/examples/combobox/combobox-select-only.html</a></li>
<li><a href="https://www.w3.org/WAI/ARIA/apg/patterns/combobox/">https://www.w3.org/WAI/ARIA/apg/patterns/combobox/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes</a></li>
<li><a href="https://react.dev/reference/react-dom/components/select">https://react.dev/reference/react-dom/components/select</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#try_it">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#try_it</a></li>
</ul>
<h3 id="react-component-library">React component library</h3>
<ul>
<li><a href="https://www.radix-ui.com/primitives/docs/components/select">https://www.radix-ui.com/primitives/docs/components/select</a></li>
<li><a href="https://atlassian.design/components/select/">https://atlassian.design/components/select/</a></li>
<li><a href="https://mui.com/material-ui/react-select/">https://mui.com/material-ui/react-select/</a></li>
<li><a href="https://ant.design/components/select">https://ant.design/components/select</a></li>
<li><a href="https://mantine.dev/core/select/">https://mantine.dev/core/select/</a></li>
</ul>
<h3 id="블로그">블로그</h3>
<ul>
<li><a href="https://blog.logrocket.com/creating-custom-select-dropdown-css/">https://blog.logrocket.com/creating-custom-select-dropdown-css/</a></li>
<li><a href="https://so-so.dev/react/make-select/">https://so-so.dev/react/make-select/</a></li>
<li><a href="https://www.freecodecamp.org/news/how-to-build-an-accessible-custom-dropdown-select-element/">https://www.freecodecamp.org/news/how-to-build-an-accessible-custom-dropdown-select-element/</a></li>
</ul></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/react">React</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/select">select</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/react/tanstack-query-ts-and-undefined"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">tanstack query + ts에서 undefined 매개변수 엄격하게 처리하기</div></a></nav><div></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#들어가기에-앞서">들어가기에 앞서</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#배경">배경</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#다른-태그로-접근하기">다른 태그로 접근하기</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#native-select와-구조-맞추기">native select와 구조 맞추기</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#select-안에-들어갈-요소-정하기">Select 안에 들어갈 요소 정하기</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#focus-구현">Focus 구현</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#slot">Slot</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#select">Select</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#option-ref-모으기">option ref 모으기</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#접근성-챙기기">접근성 챙기기</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#selecttsx">Select.tsx</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#slottsx">Slot.tsx</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#slotgrouptsx">SlotGroup.tsx</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#native-select-element-활용하기">native select element 활용하기</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#form-접근"><code>&lt;form&gt;</code> 접근.</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#autocomplete-특성">autocomplete 특성</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#따라서">따라서</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#optgroup-고려하기">optgroup 고려하기</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#마치며">마치며</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#reference">reference</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#접근성-태그">접근성, 태그</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#react-component-library">React component library</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/make-select#블로그">블로그</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
        Powered by <a href="https://docusaurus.io/" target="_blank" rel="noreferrer noopener">Docusaurus 2</a>, Hosted by <a href="https://github.com/" target="_blank" rel="noreferrer noopener">github pages</a>
        <br>
        Copyright © 2022 <a href="https://github.com/d0dam" target="_blank" rel="noreferrer noopener">minjaeKim</a>. All rights reserved.
        </span></div></div></div></footer></div>
</body>
</html>