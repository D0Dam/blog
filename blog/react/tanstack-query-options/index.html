<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">tanstack query를 프로젝트에서 어떻게 사용하면 좋을까? | d0dam&#x27;s-log</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://d0dam.xyz/blog/react/tanstack-query-options"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="tanstack query를 프로젝트에서 어떻게 사용하면 좋을까? | d0dam&#x27;s-log"><meta data-rh="true" name="description" content="회사에서 지금까지 사용된 tanstack query의 구조를 개선하면서 들었던 고민과 해결 방법을 적어보고자 합니다."><meta data-rh="true" property="og:description" content="회사에서 지금까지 사용된 tanstack query의 구조를 개선하면서 들었던 고민과 해결 방법을 적어보고자 합니다."><meta data-rh="true" name="keywords" content="React,react 지도,react memo,memo,메모이제이션"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-03-31T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/d0dam"><meta data-rh="true" property="article:tag" content="React"><link data-rh="true" rel="icon" href="/img/logos/favicon.ico"><link data-rh="true" rel="canonical" href="https://d0dam.xyz/blog/react/tanstack-query-options"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/tanstack-query-options" hreflang="ko"><link data-rh="true" rel="alternate" href="https://d0dam.xyz/blog/react/tanstack-query-options" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://d0dam.xyz/blog/react/tanstack-query-options","mainEntityOfPage":"https://d0dam.xyz/blog/react/tanstack-query-options","url":"https://d0dam.xyz/blog/react/tanstack-query-options","headline":"tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?","name":"tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?","description":"회사에서 지금까지 사용된 tanstack query의 구조를 개선하면서 들었던 고민과 해결 방법을 적어보고자 합니다.","datePublished":"2024-03-31T00:00:00.000Z","author":{"@type":"Person","name":"minjae Kim","url":"https://github.com/d0dam","email":"smallkdb@gmail.com","image":"https://avatars.githubusercontent.com/u/51052049?v=4"},"keywords":["React","react 지도","react memo","memo","메모이제이션"],"isPartOf":{"@type":"Blog","@id":"https://d0dam.xyz/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d0dam&#39;s-log RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d0dam&#39;s-log Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-DBVZBC9QT5","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DBVZBC9QT5"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DBVZBC9QT5",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.c41d10ff.css">
<script src="/assets/js/runtime~main.bd78b476.js" defer="defer"></script>
<script src="/assets/js/main.1d2c63fc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" target="_self" href="/"><div class="navbar__logo"><img src="/img/logos/main.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logos/darkModeMain.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/overview">Documents</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/make-select">Select 컴포넌트 css 커스텀을 위한 여정</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/tanstack-query-ts-and-undefined">tanstack query + ts에서 undefined 매개변수 엄격하게 처리하기</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/react/tanstack-query-options">tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/config-stylelint">styled-components stylelint적용과 자동수정(feat. yarn berry에서 pnpm으로)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/react/implement-drag-scroll">마우스 드래그 스크롤 구현하기</a></li></ul></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">tanstack query를 프로젝트에서   어떻게 사용하면 좋을까?</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-03-31T00:00:00.000Z">2024년 3월 31일</time> · <!-- -->약 15분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/51052049?v=4" alt="minjae Kim"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/d0dam" target="_blank" rel="noopener noreferrer"><span>minjae Kim</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>회사에서 지금까지 사용한 tanstack query의 구조를 개선하면서 들었던 고민과 해결 방법을 적어보고자 합니다.</p>
<p>이 글은 tanstack query의 기본 개념을 알고 있다는 가정 하에 작성하였습니다.</p>
<h2 id="비동기-상태-관리에-대한-생각">비동기 상태 관리에 대한 생각</h2>
<p><a href="https://www.npmjs.com/package/@tanstack/react-query">tanstack query</a>는 비동기 상태 관리를 위해 사용합니다.
어쩌면 요즘 프론트 개발자들이 가장 많이 사용하는 도구라고 이야기해도 무방할 정도로 많은 다운로드 수를 기록하고 있죠.
이 지표가 프론트 개발에 있어 비동기 상태 관리가 얼마나 중요한지 보여준다고 생각합니다.</p>
<p>같은 생각입니다.
저는 프론트 개발에 있어서 가장 중요한 요소가 <strong>비동기</strong>와 <strong>상태 관리</strong>라고 생각합니다.
결국 사용자의 경험을 극대화 시키기 위해서는 비동기 상태를 어떻게 보여줄지를 빼 놓을 수 없는 것 같습니다.
그래서일까요?
더 좋은 경험을 위해 디테일하게 코드를 작성하게 됩니다.
기본 구조가 좋지 않으면 개발자는 코드 유지보수가 점점   힘들어지고 재활용하기도, 읽기도 많이 불편할겁니다.</p>
<h2 id="앞으로를-위해">앞으로를 위해</h2>
<p>저희 회사에서도 react 기반에 tanstack query v4를 사용합니다.
하지만 구조 자체가 확실히 잡혀 있지 않았습니다.
필요할 때마다 가져다 쓴 탓일까요?
어떤 비동기 상태는 훅으로 묶여있기도 하고, 어떤 비동기 상태는 <code>axios apiClient</code>로 그냥 사용하고 있습니다.
api 요청 로직과 tanstack query, 그리고 커스텀 훅까지 갖는 서로간의 의존성도 강합니다.
그래서 새로운 요구사항이 나올 때마다 동일한 api를 사용하더라도 api로직부터 새로 작성해야 되죠.</p>
<p>비동기 상태를 잘 관리하기 위해 도입한 tanstack query일텐데, 이 장점을 전혀 못 살리고 있는 것처럼 보였습니다.
그래서 tanstack query v5를 도입하면서 버전업도 하고, 구조를 팀원들과 같이 잡아보기로 했습니다.</p>
<h2 id="query-key-관리">query key 관리</h2>
<admonition title="참고" type="note"><p>이번 글에서는 비동기 로직를 api 로직을 예시로 설명하고 있습니다.</p></admonition>
<p><a href="https://tkdodo.eu/blog/effective-react-query-keys"><code>query key factory</code></a> 라는 개념을 사용하기로 했습니다.
tanstack query에서 query key는 특정 query에 대한 고유 의존성을 줄 수 있습니다.
그리고 이 query key는 필수값이죠.</p>
<p>대체적으로 이 query key에 변동을 주어 query function을 재호출하거나 <code>queryClient.invalidateQueries</code> 를 사용해 특정 키에 해당하는 queries를 무효화 해주기도 합니다.
맞습니다. 마치 <code>useEffect</code>의 의존성과 같이 동작합니다.
query function이 많아질 때마다 고유의 query key가 많아지게 됩니다.
어떤 문제가 생길가요?</p>
<ul>
<li>중복되면 안되는 query key가 중복될 수 있습니다.</li>
<li>같은 query key를 사용해야해도 똑같이 일일히 적어주어야 합니다.</li>
<li>특정 query function을 초기화 하고 싶을 때 query key를 계속 찾게 되면 수고스러움이 있습니다.</li>
</ul>
<p><code>query key factory</code>는 위의 문제를 해결하기 위해 사용했습니다.</p>
<h3 id="query-key-나누기">query key 나누기</h3>
<p>이전에 회사 프로젝트에 쓰인 query key는 특정 기준 없이 처음 사용하는 인원이 작성했기 때문에 불안정했습니다.
그래서 query key factory를 만들기 앞서, query key를 어떻게 나눌 건지 팀에 확실히 알려줄 필요가 있었습니다.</p>
<p>query key가 길어지는 대부분의 경우가 api 호출이기 때문에 api 호출을 예시로 들겠습니다.</p>
<p>아래와 같은 api url은 query key를 작성할 때 크게 문제가 되지 않았습니다.</p>
<pre><code class="language-ts" metastring="title=&quot;course&quot;">const course = &#x27;https://examaple.com/course&#x27;;
const courseDetail = &#x27;https://examaple.com/course/:id&#x27;;

const courseQueryKeys = [&#x27;course&#x27;];
const courseDetailsQueryKeys = (id) =&gt; [&#x27;course&#x27;, id];
</code></pre>
<p>하지만 아래와 같은 경우는 어떻게 할까요?</p>
<pre><code class="language-ts" metastring="title=&quot;courseLecture&quot;">const courseLecture = &#x27;https://examaple.com/course/:id/lecture/:id?sort=new&amp;type=selling&amp;page=0&amp;size=10&#x27;;
</code></pre>
<p>바로 어떻게 나눌지 감이 딱 왔을까요?
크게 query key에 글어갈 값을 3가지로 나누어 볼 수 있습니다.</p>
<ol>
<li>url에 포함된 연관있는 도메인명: &#x27;course&#x27;, &#x27;lecture&#x27;</li>
<li>id: &#x27;courseId&#x27;, &#x27;lectureId&#x27;</li>
<li>query params: &#x27;sort&#x27;, &#x27;type&#x27;, &#x27;page&#x27;, &#x27;size&#x27;</li>
</ol>
<p>1, 2번째의 경우는 차례대로 query key 배열에 포함시키면 될 것 같습니다.
3번째의 경우는 객체로 관리해 query params 각각이 고유의 key가 되지  않도록 했습니다.
그러면 아래와 같이 query key를 정리할 수 있을 것 같습니다.</p>
<pre><code class="language-ts" metastring="title=&quot;courseLecture&quot;">const courseLecture = &#x27;https://examaple.com/course/1/lecture/2?sort=new&amp;type=selling&amp;page=0&amp;size=10&#x27;;
const courseId = 1;
const lectureId = 2;
const queryParams = {
  sort: &#x27;new&#x27;,
  type: &#x27;selling&#x27;,
  page: 0,
  size: 10,
};

const courseLectureQueryKeys = (courseId, lectureId, queryParams) =&gt; [
  &#x27;course&#x27;,
  courseId,
  &#x27;lecture&#x27;,
  lectureId,
  queryParams,
];
</code></pre>
<p>이제 한 도메인에 대해 아래와 같이 query key만을 별도 객체로 모아 관리를 할 수 있습니다.</p>
<pre><code class="language-ts" metastring="title=&quot;course query key factory&quot;">const courseKeys = {
  all: [&#x27;course&#x27;] as const,
  detail: (courseId: number) =&gt; [&#x27;course&#x27;, courseId] as const,
  lectures: (courseId: number) =&gt; [...courseKeys.detail(courseId), &#x27;lecture&#x27;] as const,
  // queryParams의 경우 안의 값이 optional 일지 아닐지에 대해 꼭 안넘겨 주어도 될 수 있습니다.
  lectureDetail: (courseId: number, lectureId: number, queryParams: LectureParams) =&gt;
    [...courseKeys.lectures(courseId), lectureId, { queryParams }] as const,
};
</code></pre>
<h2 id="구조-잡기">구조 잡기</h2>
<p>이제 query factory도 만들었으니 구조를 한 번 잡아봅시다.</p>
<p>모든 비동기 상태에 대해 훅으로 묶어주기로 했습니다.</p>
<pre><code class="language-ts" metastring="title=&quot;useCourseQuery.ts&quot;">import { useQuery } from &#x27;@tanstack/react-query&#x27;;

import { getCourse } from &#x27;@/apis/course&#x27;;
import { courseKeys } from &#x27;@/hooks/query/keyFactory/courseKeys&#x27;;

function useCourseQuery() {
  const course = useQuery({
    queryKey: courseKeys.all,
    queryFn: getCourse,
  });

  return course;
}

export default useCourseQuery;
</code></pre>
<p>파 일 이름은 <code>use~~~Query</code>, <code>use~~~Mutation</code> 으로 통일하기로 했습니다.</p>
<p>회사의 경우 같은 비동기 상태들을 admin이나 개편 페이지 제작에도 동일하게 많이 사용하는 편이었습니다.
그래서 최대한 추후에도 따로 분리해서 사용할 수 있도록 root의 <code>hooks/queries</code> 폴더에두고 이 폴더에 <code>queryFactory</code>를 두었습니다.</p>
<p>아래와 같은 구조가 되겠네요!</p>
<pre><code>└── 📁hooks
    └── 📁queries
        └── 📁keyFactory
            └── courseKeys.ts
        └── useCourseQuery.ts
        └── useCourseMutation.ts
</code></pre>
<p>이제 특정 query를 사용할 때 필요한 훅을 가져와 쓰면 되겠네요!</p>
<pre><code class="language-tsx" metastring="title=&quot;Course.tsx&quot;">import CourseItem from &#x27;@/components/CourseItem&#x27;;
import useCourseQuery from &#x27;@/hooks/queries/useCourseQuery&#x27;;

function Course() {
  const { data: course } = useCourseQuery();

  return &lt;CourseItem {...course} /&gt;;
}

export default Course;
</code></pre>
<h2 id="아쉬움-고민">아쉬움, 고민</h2>
<p>이 구조를 잡고 들여오면서 몇일 사용해 본 결과, 아쉬운 부분이 있었습니다.</p>
<ul>
<li>query key와 query key를 사용하는 훅이 응집력을 좀 더 가져도 좋았을 것 같습니다.<!-- -->
<ul>
<li>query key와 훅이 별도의 폴더와 파일로 분리되어 있어서 co-location을 이루지 못한 것 같습니다.</li>
</ul>
</li>
<li>하나의 비동기 상태에 대해 useSuspenseQuery와 useQuery, useQueries, prefetch 등의 메서드를 선택적으로 쓰기 힘듭니다.<!-- -->
<ul>
<li>처음부터 특정 비동기 상태에 대한 훅을 만들어 버리기 때문입니다.</li>
</ul>
</li>
<li>현재의 구조는 tanstack query v5로 올린 의미가 없는 형태라고 느껴졌습니다.<!-- -->
<ul>
<li>v5의 최대 변화점은 여러 인자들이 객체로 넘기게끔 변했다는 점입니다. 이 점을 제대로 활용해보지 못한 것 같습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>&#x27;아예 특정 query를 넘기기 위한 객체 인자들을 묶어주면 어떨까?&#x27;</p>
</blockquote>
<p>찾아보니, 떡하니 있더군요.🥲 바로 <a href="https://tanstack.com/query/v5/docs/framework/react/reference/queryOptions"><code>query options</code></a>입니다.</p>
<h2 id="query-options">query options</h2>
<p>query options는 특정 query 메서드에 대한 인자 객체를 정의할 수 있게 해줍니다.
예를 들어봅시다.</p>
<pre><code class="language-ts" metastring="title=&quot;courseQueryOptions.ts&quot;">import { queryOptions } from &#x27;@tanstack/react-query&#x27;;

const courseQueryOptions = queryOptions({
  queryKey: [&#x27;course&#x27;],
  queryFn: getCourse,
});
</code></pre>
<p>이게 위에서 말한 문제들을 해결해 줄까요? 한 번 확인해 봅시다.</p>
<ul>
<li>query key와 query key를 사용하는 훅이 응집력을 좀 더 가져도 좋았을 것 같습니다.</li>
</ul>
<p>-&gt; 이제 query key를 따로 분리하는 구조가 아니기 때문에 같은 객체에 선언해 놓을 수 있습니다. 아래와 같이 말이죠.</p>
<pre><code class="language-ts" metastring="title=&quot;courseQueries.ts&quot;">import { queryOptions } from &#x27;@tanstack/react-query&#x27;;

import type { CourseListParams } from &#x27;@/types/course/remote&#x27;;

const courseQueries = {
  allKeys: [&#x27;course&#x27;] as const,
  all: () =&gt;
    queryOptions({
      queryKey: courseQueries.allKeys(),
      queryFn: () =&gt; getCourse(),
    }),
  listKeys: (params: CourseListParams) =&gt; [...courseQueries.allKeys(), params],
  list: (params: CourseListParams) =&gt;
    queryOptions({
      queryKey: courseQueries.listKeys(params),
      queryFn: () =&gt; getCourseList(params),
    }),
};
</code></pre>
<ul>
<li>하나의 비동기 상태에 대해 useSuspenseQuery와 useQuery, useQueries, prefetch 등의 메서드를 선택적으로   쓰기 힘듭니다.</li>
</ul>
<p>-&gt; 사실 이제 훅을 만들 필요가 없어졌습니다. Mutation을 훅으로 만든다면 만들 수 있겠지만 이제 필요한 곳에서 특정 queryOptions를 꺼내 사용하면 됩니다.</p>
<pre><code class="language-tsx" metastring="title=&quot;Course.tsx&quot;">import CourseItem from &#x27;@/components/CourseItem&#x27;;
import { useQuery } from &#x27;@tanstack/react-query&#x27;;

function Course() {
  const { data: course } = useQuery(courseQueries.all());
  // 이제 이렇게 선택적으로 사용하면 됩니다.
  // const { data: course } = useSuspenseQuery(courseQueries.all());

  return &lt;CourseItem {...course} /&gt;;
}

export default Course;
</code></pre>
<ul>
<li>현재의 구조는 tanstack query v5로 올린 의미가 없는 형태라고 느껴졌습니다.</li>
</ul>
<p>-&gt; 이제 queryOptions를 활용해 인자를 객체로 관리하면서 버전업에 대해 의미를 둘 수도 있겠네요!</p>
<h2 id="다시-구조-잡기">다시, 구조 잡기</h2>
<p>변한 형식에 따라 구조를 새로 잡아봅시다.
사실, 객체로 비동기 상태 로직을 관리하게 되면서 훅과의 의존성도 끊어줄 수 있었습니다.
그래서 root에 이 query 만을 관리하는 폴더를 둘 수 있게 되었죠.</p>
<pre><code class="language-title=&quot;root/src&quot;">└── 📁queryFactory // queries도 좋아 보입니다.
    └── alarmQueries.ts
    └── classroomQueries.ts
    └── courseQueries.ts
    └── userQueries.ts
</code></pre>
<p>각각의 queries 들은 tanstack query v5를 사용하는 어디에서든지 자유롭게 꺼내 쓸 수 있게 독립된 환경이 만들어졌습니다.</p>
<h2 id="이런건-안되는거-아닌가요">이런건 안되는거 아닌가요?</h2>
<p>이 구조를 사용하다 보니 팀원들에게 다음과 같은 질문들이 나오더군요.</p>
<admonition type="tip"><blockquote>
<p>Q: useInfinityQuery를 사용할 땐 queryOptions를 사용할 수 없어요..!</p>
</blockquote><p>A: <a href="https://tanstack.com/query/v5/docs/framework/react/reference/infiniteQueryOptions">infiniteQueryOptions</a>도 있답니다!</p></admonition>
<admonition type="tip"><blockquote>
<p>Q: Mutation도 객체로 묶어서 관리할 수 없을까요?</p>
</blockquote><p>A: 이건 좀 다른 이야기 같습니다.
mutation의 경우 촉발 메서드가 <code>useMutation</code> 밖에 없습니다.
그리고 다른 mutation 기능 간에도 옵션이 같을 수가 없죠.
때문에 굳이 옵션을 공유할 일이 없지 않을까요?
같은 mutation을 여러 군데에서 사용한다면 해당 mutation을 훅으로 묶어주면 됩니다.</p></admonition>
<h2 id="마무리">마무리</h2>
<p>이렇게 비동기 상태에 대한 구조를 완전히 바꾸어서 도입을 해 보았습니다.</p>
<p>결과적으로 대만족! 입니다. 개발자 경험 특면에서도 앞으로도 이용 가능한, 한 눈에 보기 쉬운 구조여서 좋았습니다.
특히 queryOptions를 가지고 어떤 메서드를 사용할 지 열리게 둔 점이 앞으로의 ui를 그릴 때 좀 더 넓은 시각으로 바라볼 수 있게 된 것 같습니다.</p>
<p>&#x27;tanstack query를 프로젝트에서 어떻게 사용하면 좋을까?&#x27;에 대한 질문이 조금이나마 해소 되었기를 바랍니다.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/react">React</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/react/tanstack-query-ts-and-undefined"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">tanstack query + ts에서 undefined 매개변수 엄격하게 처리하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/react/config-stylelint"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">styled-components stylelint적용과 자동수정(feat. yarn berry에서 pnpm으로)</div></a></nav><div></div></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#비동기-상태-관리에-대한-생각">비동기 상태 관리에 대한 생각</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#앞으로를-위해">앞으로를 위해</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#query-key-관리">query key 관리</a><ul><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#query-key-나누기">query key 나누기</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#구조-잡기">구조 잡기</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#아쉬움-고민">아쉬움, 고민</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#query-options">query options</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#다시-구조-잡기">다시, 구조 잡기</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#이런건-안되는거-아닌가요">이런건 안되는거 아닌가요?</a></li><li><a class="table-of-contents__link toc-highlight" href="/blog/react/tanstack-query-options#마무리">마무리</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
        Powered by <a href="https://docusaurus.io/" target="_blank" rel="noreferrer noopener">Docusaurus 2</a>, Hosted by <a href="https://github.com/" target="_blank" rel="noreferrer noopener">github pages</a>
        <br>
        Copyright © 2022 <a href="https://github.com/d0dam" target="_blank" rel="noreferrer noopener">minjaeKim</a>. All rights reserved.
        </span></div></div></div></footer></div>
</body>
</html>